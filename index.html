<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reset.css">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/monokai.css">

		<!-- Overrides -->
		<link rel="stylesheet" href="lib/css/kevin.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section data-markdown>
					<textarea data-template>
						# Estructuras de Datos Avanzadas

						Presentado por Kevin Peña
					</textarea>
				</section>

				<section data-markdown id="cola-pila">
					<textarea data-template>
						## Cola y Pila

						Son estructuras de datos lineales caracterizadas por el orden que
						tienen sus elementos en entrar y salir de la estructura.

						- FIFO (Cola) <!-- .element: class="fragment" data-fragment-index="1" -->
						- LIFO (Pila) <!-- .element: class="fragment" data-fragment-index="2" -->
					</textarea>
				</section>

				<section id="cola">
					<h2>Cola</h2>
					<ul>
						<li>Su nombre es una analogía a una cola o fila en la vida real.</li>
						<li>Es First In First Out (El primero en entrar es el primero en salir).</li>
					</ul>
					<style>
						.queue-anim {
							margin-top: 64px;
							display: flex;
							flex-direction: row;
							justify-content: center;
						}
						.queue-anim .elem {
							width: 48px;
							height: 96px;
							background-color: #eb4034;
							border: 1px solid white;
							margin: 4px;
						}
						.queue-anim .first {
							opacity: 0;
							transform: rotate(45deg);
							transform-origin: right -50%;
						}
						.queue-anim.push {
							transform: translateX(58px);
							transition: all .25s ease-in;
						}
						.queue-anim.push .first {
							transform: none;
							opacity: 1;
							transition: all .25s ease-in;
						}
						.queue-anim .last {
							opacity: 1;
							transform: none;
							transform-origin: left 150%;
						}
						.queue-anim.pop .last {
							opacity: 0;
							transform: rotate(45deg);
							transition: all .25s ease-in;
						}
					</style>
					<div class="queue-anim">
						<div class="elem first"></div>
						<div class="elem"></div>
						<div class="elem"></div>
						<div class="elem"></div>
						<div class="elem last"></div>
					</div>
					<script type="text/javascript">
						function sleep(ms) {
							return new Promise(resolve => setTimeout(resolve, ms))
						}
						async function queueAnim() {
							const anim = document.querySelector('.queue-anim')
							await sleep(2000)
							while (true) {
								anim.classList.add('push')
								await sleep(1500)
								anim.classList.add('pop')
								await sleep(1000)
								anim.classList.remove('pop', 'push')
								await sleep(250)
							}
						}
						queueAnim()
					</script>
				</section>

				<section id="cola-ejemplo">
					<h2>Ejemplo</h2>
					<div class="queue-example">
						<div class="add-task">
							<input id="datos" type="text" placeholder="Datos de la tarea">
							<input id="dificultad" type="text" placeholder="Dificultad">
							<button>Agregar</button>
						</div>
						<div class="out-container">
							<div>
								<h5>Cola</h5>
								<div class="queue"></div>
							</div>
							<div>
								<h5>Tareas Finalizadas</h5>
								<div class="completed"></div>
							</div>
						</div>
					</div>
					<style>
						.queue-example .out-container {
							display: flex;
							flex-direction: row;
							justify-content: space-around;
						}
						.queue-example .out-container > div {
							flex: 1;
							min-height: 200px;
							max-width: 400px;
							max-height: 300px;
							background-color: #272822;
							font-family: monospace;
							font-size: 12px;
							word-wrap: break-word;
							text-align: left;
							overflow-y: auto;
						}
					</style>
					<script type="text/javascript" src="lib/js/sha256.min.js"></script>
					<script type="text/javascript">
						class Cola {
							constructor() {
								this.array = []
							}

							push(elem) {
								this.array.unshift(elem)
							}

							pop() {
								return this.array.pop()
							}

							peek() {
								return this.array[this.array.length - 1]
							}

							empty() {
								return this.array.length === 0
							}
						}

						const cola = new Cola()

						function agregarTarea(data, dificultad, onAvance) {
							const tarea = new Tarea(data, dificultad, onAvance)

							cola.push(tarea)
							actualizarCola()
						}

						async function procesar() {
							while (true) {
								if (cola.empty()) {
									await sleep(0)
								} else {
									const tareaAProcesar = cola.peek()
									const resultado = await tareaAProcesar.ejecutar()
									cola.pop()
									agregarResultado(tareaAProcesar, resultado)
									actualizarCola()
								}
							}
						}

						procesar()

						// Detalles para mostrar resultados en pantalla

						function agregarResultado(tarea, resultado) {
							const resElem = document.querySelector('.queue-example .completed')
							const p = document.createElement('p')
							p.innerHTML = `${tarea.datos}${tarea.nonce} (${tarea.dificultad}): ${resultado}`
							resElem.appendChild(p)
						}

						function actualizarCola() {
							const resElem = document.querySelector('.queue-example .queue')
							let html = ''
							for (let i = 0; i < cola.array.length; ++i) {
								const tarea = cola.array[i]
								html += `<p>${tarea.datos} (${tarea.dificultad})`
								if (i === (cola.array.length - 1)) {
									html += '<span id="trabajo"></span>'
								}
								html += '</p>'
							}
							resElem.innerHTML = html;
						}

						document.querySelector('.queue-example button').addEventListener('click', () => {
							const datos = document.querySelector('.queue-example #datos').value
							const dificultad = Number(document.querySelector('.queue-example #dificultad').value)
							const onAvance = (nonce, hash) => {
								const resElem = document.querySelector('.queue-example #trabajo')
								if (resElem) {
									resElem.innerHTML = `${nonce}: ${hash}`
								}
							}

							agregarTarea(datos, dificultad, onAvance)
							actualizarCola()

							document.querySelector('.queue-example #datos').value = ''
							document.querySelector('.queue-example #dificultad').value = ''
							document.querySelector('.queue-example #datos').focus()
						})

						function sleep(ms) {
							return new Promise(resolve => setTimeout(resolve, ms))
						}

						class Tarea {
							constructor(datos, dificultad, onAvance) {
								this.datos = datos
								this.dificultad = dificultad
								this.onAvance = onAvance
								this.nonce = -1
							}

							async ejecutar() {
								let hash = null
								do {
									this.nonce++
									hash = sha256.create();
									hash.update(this.datos + String(this.nonce));
									if (this.onAvance && this.nonce % 7 === 0) {
										const binario = this.digestABinario(hash.digest())
										this.onAvance(this.nonce, binario)
									}
									await sleep(0)
								} while (!this.verificarRespuesta(hash.digest(), this.dificultad))
								return this.digestABinario(hash.digest())
							}

							digestABinario(digest) {
								let binario = ''
								for (const byte of digest) {
									binario += byte.toString(2).padStart(8, '0')
								}
								return binario
							}

							verificarRespuesta(hashDigest, dificultad) {
								let binary = ''
								let i = 0
								do {
									binary += hashDigest[i].toString(2).padStart(8, '0')
									++i
								} while (binary.length < dificultad)

								return binary.startsWith('0'.repeat(dificultad))
							}
						}
					</script>
				</section>

				<section data-markdown id="tamano">
					<textarea data-template>
						## Tamaño

						```cpp
						// Recordemos
						struct Persona {
							array<char, 10> nombre;
							int edad;
						};
						```

					</textarea>
				</section>

				<section data-markdown id="tamano-illust">
					<textarea data-template>
						## Tamaño (gráficamente)

						![](lib/tamano-illust.png)

					</textarea>
				</section>

				<section id="tamano-prove">
					<h2>Tamaño (demostración)</h2>
					<iframe width="800px" height="400px" src="https://godbolt.org/e#g:!((g:!((g:!((h:codeEditor,i:(j:1,lang:c%2B%2B,source:'%23include+%3Carray%3E%0A%23include+%3Ciostream%3E%0A%0Ausing+namespace+std%3B%0A%0Astruct+Persona+%7B%0A++array%3Cchar,+10%3E+nombre%3B%0A++int+edad%3B%0A%7D%3B%0A%0Aint+main()+%7B%0A++cout+%3C%3C+sizeof(Persona)+%3C%3C+!'%5Cn!'%3B%0A%7D%3B'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g91,compilerOutShown:'0',execArgs:'',execStdin:'',lang:c%2B%2B,libs:!(),options:'-Os+-std%3Dc%2B%2B17',source:1,stdinPanelShown:'1'),l:'5',n:'0',o:'x86-64+gcc+9.1+Executor+(Editor+%231)+C%2B%2B',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4"></iframe>
				</section>

				<section data-markdown id="acceso">
					<textarea data-template>
						## Acceso

						```cpp
						cout << kevin.edad << '\n';
						cout << kevin.nombre.data() << '\n';
						```

					</textarea>
				</section>

				<section data-markdown id="uso">
					<textarea data-template>
						## Uso

						- Agrupar datos relacionados.
						- Expresar en el codigo terminología del dominio del problema.
						- struct es equivalente a class en C++.

					</textarea>
				</section>

				<section>
					<section data-markdown id="uso-fake">
						<textarea data-template>
							## Uso (según el PDF del módulo)

							### Estructuras anidadas.
							```cpp
							struct Ubicacion {
								string pais; string ciudad; string direccion;
							};
							struct Persona {
								string nombre;
								int edad;
								Ubicacion vivienda;
								Ubicacion trabajo;
							};
							```
						</textarea>
					</section>
					<section data-markdown id="uso-fake-2">
						<textarea data-template>
							### Arreglos de estructuras
							```cpp
							array<Persona, 4> familia;
							```
						</textarea>
					</section>

					<section data-markdown id="uso-fake-3">
						<textarea data-template>
							### Arreglos como miembros de una struct
							```cpp
							struct Persona {
								array<char, 10> nombre;
								int edad;
							};
							```
						</textarea>
					</section>
				</section>

				<section data-markdown id="tipos">
					<textarea data-template>
						## Tipos de Estructras de Datos

						- Arreglos
						- Matrices (Arreglo de arreglos)
						- Listas
						- Pilas
						- Colas
						- Arboles
						- Grafos
					</textarea>
				</section>

				<section data-markdown id="tipo-arreglo">
					<textarea data-template>
						### Arreglos

						- Conjunto de elementos
						- Contiguos en memoria
						- Tamaño predefinido

						```cpp
						array<string, 2> nombres {"Kevin", "Andres"};
						for (auto& nombre : nombres)
							cout << "Hola " << nombre << "!\n";
						```

						Salida del programa
						```
						Hola Kevin!
						Hola Andres!
						```
					</textarea>
				</section>

				<section>
					<section data-markdown id="tipo-matriz">
						<textarea data-template>
							### Matrices

							```cpp
							array<array<double, 3>, 2> notas {{
								{4.9, 4.8, 5.0},
								{4.8, 4.7, 4.9},
							}};
							for (int i = 0; i < notas.size(); ++i) {
								cout << "Notas del estudiante " << i + 1 << ": ";
								for (auto& nota : notas[i])
									cout << nota << " ";
								cout << '\n';
							}
							```

							Salida del programa
							```sh
							Notas del estudiante 1: 4.9 4.8 5
							Notas del estudiante 2: 4.8 4.7 4.9
							```
						</textarea>
					</section>

					<section data-markdown id="tipo-matriz-mejor">
						<textarea data-template>
							```cpp
							struct Estudiante {
								string nombre;
								array<double, 3> notas;
							};

							array<Estudiante, 2> estudiantes {{
								{"Kevin", {4.9, 4.8, 5.0}},
								{"Andres", {4.8, 4.7, 4.9}},
							}};

							for (auto& est : estudiantes) {
								cout << "Notas de " << est.nombre << ": ";
								for (auto& nota : est.notas)
									cout << nota << " ";
								cout << '\n';
							}
							```

							Salida del programa
							```sh
							Notas de Kevin: 4.9 4.8 5
							Notas de Andres: 4.8 4.7 4.9
							```
						</textarea>
					</section>
				</section>

				<section>
					<section data-markdown id="tipo-lista">
						<textarea data-template>
							### Listas (segun Java)

							En C++ el equivalente son los requerimientos para
							[SequenceContainer](https://en.cppreference.com/w/cpp/named_req/SequenceContainer)

							```cpp
							vector<string> nombres;
							nombres.push_back("Kevin");
							nombres.push_back("Andres");

							for (auto& nombre : nombres)
								cout << "Hola " << nombre << "!\n";
							```

							Salida del programa
							```sh
							Hola Kevin!
							Hola Andres!
							```
						</textarea>
					</section>
					<section id="tipo-lista-demo">
						<iframe width="800px" height="400px" src="https://godbolt.org/e#g:!((g:!((g:!((h:codeEditor,i:(j:2,lang:c%2B%2B,source:'%23include+%3Ciostream%3E%0A%23include+%3Clist%3E%0A%23include+%3Cstring%3E%0A%23include+%3Cvector%3E%0A%0Ausing+namespace+std%3B%0A%0Aint+main()+%7B%0A++++vector%3Cstring%3E+nombres%3B%0A++++nombres.push_back(%22Kevin%22)%3B%0A++++nombres.push_back(%22Andres%22)%3B%0A%0A++++for+(auto%26+nombre+:+nombres)%0A++++++++cout+%3C%3C+%22Hola+%22+%3C%3C+nombre+%3C%3C+%22!!%5Cn%22%3B%0A%7D'),l:'5',n:'0',o:'C%2B%2B+source+%232',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g91,compilerOutShown:'0',execArgs:'',execStdin:'',lang:c%2B%2B,libs:!(),options:'',source:2,stdinPanelShown:'1'),l:'5',n:'0',o:'x86-64+gcc+9.1+Executor+(Editor+%232)+C%2B%2B',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4"></iframe>
					</section>
				</section>

				<section data-markdown id="tipo-pila">
					<textarea data-template>
						### Pilas

						```cpp
						// Reversar un string
						stack<char, vector<char>> caracteres;
						caracteres.push('a');
						caracteres.push('m');
						caracteres.push('o');
						caracteres.push('r');

						while(!caracteres.empty()) {
							cout << caracteres.top();
							caracteres.pop();
						}
						```

						Salida del programa
						```sh
						roma
						```
					</textarea>
				</section>

				<section data-markdown id="tipo-cola">
					<textarea data-template>
						### Colas

						```cpp
						queue<string, list<string>> personas;
						personas.push("Andres");
						personas.push("Blanca");
						personas.push("Carolina");

						while(!personas.empty()) {
							cout << personas.front() << '\n'; // Atender a la persona
							personas.pop();
						}
						```

						Salida del programa
						```sh
						Andres
						Blanca
						Carolina
						```
					</textarea>
				</section>

				<section id="tipo-arbol">
					<style>
						.container{
						    display: flex;
						}
						.col{
						    flex: 1;
						}
						#tipo-arbol img {
							border: none !important;
							background-color: transparent !important;
							box-shadow: none !important;
						}
						#tipo-arbol pre code {
							max-height: 600px;
						}
					</style>

					<h3>Arboles</h3>
					<div class="container">
						<div class="col" data-markdown>
							<textarea data-template>
								```cpp
								// Arbol binario (no ordenado)
								template<typename T>
								struct Nodo {
									T datos;
									Nodo* izquierdo = nullptr;
									Nodo* derecho = nullptr;
								};

								using NodoJ = Nodo<string>;

								NodoJ jefe {"Andres"};

								NodoJ sub1 {"Blanca"};
								jefe.izquierdo = &amp;sub1;

								NodoJ sub2 {"Carolina"};
								jefe.derecho = &amp;sub2;

								NodoJ subsub {"David"};
								sub1.derecho = &amp;subsub;
								```
							</textarea>
						</div>
						<div class="col">
								<img src="lib/arbol.png">
						</div>
					</div>
				</section>

				<section id="tipo-grafo">
					<style>
						#tipo-grafo img {
							border: none !important;
							background-color: transparent !important;
							box-shadow: none !important;
						}
						#tipo-grafo pre code {
							max-height: 600px;
						}
					</style>

					<h3>Grafos</h3>
					<div class="container">
						<div class="col" data-markdown>
							<textarea data-template>
								```cpp
								template <typename T>
								struct Nodo {
									T data;
									vector<Nodo*> aristas;

									void conectar(Nodo* otro)
									{
										aristas.push_back(otro);
									}
								};

								Nodo<int> n1{1}, n2{2},
								          n3{3}, n4{4};
								n1.conectar(&n2);
								n1.conectar(&n4);
								n2.conectar(&n4);
								n3.conectar(&n1);
								n3.conectar(&n2);
								n4.conectar(&n3);

								```
							</textarea>
						</div>
						<div class="col">
								<img src="lib/grafo.png">
						</div>
					</div>
				</section>

				<section id="punteros">
					<h2>Punteros</h2>

					<ul>
						<li class="fragment" data-fragment-index="1">
							<span class="fragment" data-fragment-index="1">Un numero</span>
							<span class="fragment" data-fragment-index="2">que ha de ser interpretado como una dirección de memoria.</span>
						</li>
						<li class="fragment" data-fragment-index="3">
							Tiene asociado un tipo.
						</li>
					</ul>
				</section>

				<section id="punteros-lang">
					<h2>Punteros (lenguajes)</h2>

					<table>
						<thead>
							<tr>
								<th class="fragment" data-fragment-index="1">Lenguajes que los usan</th>
								<th class="fragment" data-fragment-index="5">Lenguajes que no los usan</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td class="fragment" data-fragment-index="2">C</td>
								<td class="fragment" data-fragment-index="6">C#</td>
							</tr>
							<tr>
								<td class="fragment" data-fragment-index="2">C++</td>
								<td class="fragment" data-fragment-index="6">Java</td>
							</tr>
							<tr>
								<td class="fragment" data-fragment-index="3">Objective C</td>
								<td class="fragment" data-fragment-index="6">Javascript</td>
							</tr>
							<tr>
								<td class="fragment" data-fragment-index="4">Go</td>
								<td class="fragment" data-fragment-index="6">Python</td>
							</tr>
							<tr>
								<td class="fragment" data-fragment-index="4">Julia</td>
								<td class="fragment" data-fragment-index="6">Haskell</td>
							</tr>
							<tr>
								<td class="fragment" data-fragment-index="4">Rust</td>
								<td class="fragment" data-fragment-index="6">Lua</td>
							</tr>
							<tr>
								<td class="fragment" data-fragment-index="4">D</td>
								<td class="fragment" data-fragment-index="6">Visual Basic</td>
							</tr>
							<tr>
								<td class="fragment" data-fragment-index="4">Pascal</td>
							</tr>
						</tbody>
					</table>
				</section>

				<section data-markdown id="punteros-vs-1">
					<textarea data-template>
						## Punteros (C vs C++)

						Pasar un array en C
						```c
						int suma_c(int *arr, int size);
						// al llamarlo
						int mi_array[] = {1, 2, 3};
						suma_c(mi_array, 5); // ups, segfault
						suma_c(mi_array, sizeof(mi_array) / sizeof(mi_array[0])); // largo
						```

						Pasar un array en C++
						```cpp
						template<int N>
						int suma(const array<int, N>& arr);
						// al llamarlo
						array<int> mi_array {1, 2, 3};
						suma(mi_array); // no hay forma de pasar el tamaño incorrecto
						```
					</textarea>
				</section>

				<section data-markdown id="punteros-vs-2">
					<textarea data-template>
						## Punteros (C vs C++)

						Memoria dinámica
						```c
						int tamano = 10; // asume que viene del usuario
						int* mi_array = (int*) malloc(tamano * sizeof(int));

						// usar mi_array

						free(mi_array); // no lo olvides o vas a fugar memoria
						```

						Memoria dinámica en C++
						```cpp
						int tamano = 10; // asume que viene del usuario
						vector<int> mi_vec(tamano); // reserva 10 pero puede crecer

						// usar mi_vec
						```
					</textarea>
				</section>

				<section data-markdown id="punteros-vs-3">
					<script type="text/template">
						## Punteros (C vs C++)

						Pasar una funcion en C
						```c
						int contar_si(int *arr, int size, bool (*pred)(int)) {
							int suma = 0;
							for (int i = 0; i < size; ++i)
								if (pred(arr[i])) suma++;
							return suma;
						}
						```

						Pasar una funcion en C++
						```cpp
						template <typename Cont, typename Func>
						int contar_si(const Cont& cont, Func pred) {
							int suma = 0;
							for (auto& elem : cont)
								if (pred(elem)) suma++;
							return suma;
						}
						```
					</script>
				</section>

				<section data-markdown id="punteros-vs-3">
					<script type="text/template">
						# Gracias
					</script>
				</section>
			</div>
		</div>

		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true }
				],
				hash: true,
			});
		</script>
	</body>
</html>
